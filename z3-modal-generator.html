---
layout: null
---
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zebra 3 Modal Generator</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Custom Head (Sidebar/Theme) -->
    {% include head-custom.html %}

    <style>
        :root {
            --bg-color: #1a1a1a;
            --card-bg: #252525;
            --text-color: #e0e0e0;
            --text-muted: #a0a0a0;
            --accent-color: #8cc63f;
            /* Zebra-ish green */
            --accent-hover: #7ab332;
            --input-bg: #2a2a2a;
            --border-color: #333333;
            --code-bg: #111111;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 2rem;
            padding-left: calc(210px + 2rem);
            /* Offset for pinned sidebar (210px) */
        }

        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(90deg, #fff, var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        p.subtitle {
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        .card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        label {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-muted);
        }

        textarea {
            width: 100%;
            height: 120px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: white;
            padding: 1rem;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            resize: vertical;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        textarea:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(140, 198, 63, 0.2);
        }

        button.primary-btn {
            background-color: var(--accent-color);
            color: #1a1a1a;
            border: none;
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 700;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.1s, background-color 0.2s;
            align-self: center;
        }

        button.primary-btn:hover {
            background-color: var(--accent-hover);
        }

        button.primary-btn:active {
            transform: scale(0.98);
        }

        .output-section {
            margin-top: 1rem;
            display: none;
            /* Hidden by default */
            flex-direction: column;
            gap: 0.5rem;
        }

        .output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .copy-btn {
            background-color: transparent;
            color: var(--text-muted);
            border: 1px solid var(--border-color);
            padding: 4px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            color: white;
            border-color: white;
        }

        pre {
            background-color: var(--code-bg);
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            color: #dcdcdc;
            border: 1px solid var(--border-color);
        }

        /* Keyword highlighting for coolness */
        span.highlight {
            color: var(--accent-color);
        }
    </style>
</head>

<body>

    <div class="container">
        <div>
            <h1>Zebra 3 Modal Generator</h1>
            <p class="subtitle">Describe the sound, and the physics engine will design its resonator profile.</p>
        </div>

        <div class="card">
            <div class="input-group">
                <label for="prompt">Sound Description</label>
                <textarea id="prompt" placeholder="e.g. Stiff Metal Bell with a long decay..."></textarea>
            </div>

            <button class="primary-btn" onclick="generate()">Generate Profile</button>

            <div class="output-section" id="outputSection">
                <div class="output-header">
                    <label>Generated CSV</label>
                    <button class="copy-btn" onclick="copyToClipboard()">Copy to Clipboard</button>
                </div>
                <pre id="output">Ratio;GainDB;Decay</pre>
            </div>
        </div>
    </div>

    <script>
        // --- SEEDING UTILITIES ---
        // Simple hash function (cyrb53) to turn string into seed
        function cyrb53(str, seed = 0) {
            let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
            for (let i = 0, ch; i < str.length; i++) {
                ch = str.charCodeAt(i);
                h1 = Math.imul(h1 ^ ch, 2654435761);
                h2 = Math.imul(h2 ^ ch, 1597334677);
            }
            h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
            h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
            return 4294967296 * (2097151 & h2) + (h1 >>> 0);
        }

        // Mulberry32 PRNG
        function mulberry32(a) {
            return function () {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        function generate() {
            const promptInput = document.getElementById('prompt').value;
            // Use raw case-sensitive input for seeding, but lowercase for keyword matching
            const prompt = promptInput.toLowerCase();
            const outputEl = document.getElementById('output');
            const outputSection = document.getElementById('outputSection');

            // --- 0. INITIALIZE RNG ---
            // If prompt is empty, use a random seed. If text exists, hash it.
            const seed = promptInput.trim() === "" ? Date.now() : cyrb53(promptInput);
            const rng = mulberry32(seed); // rng() returns 0.0 to 1.0

            // --- CONFIGURATION ---
            const targetPartials = 64;
            let ratios = [];

            // --- 1. MATERIAL & TOPOLOGY (Ratios) ---

            let topology = null;
            let stiffness = 0.0;
            let detuneAmount = 0.0;
            let clusterProb = 0.0;

            // Keyword Matching
            if (prompt.match(/bell|gong|chime|plate/)) {
                topology = 'inharmonic';
                detuneAmount = 0.15;
            } else if (prompt.match(/glass|crystal|ice|shatter/)) {
                topology = 'inharmonic';
                detuneAmount = 0.05;
                clusterProb = 0.2;
            } else if (prompt.match(/wood|log|marimba|xylophone/)) {
                topology = 'stiff_string';
                stiffness = 0.1;
            } else if (prompt.match(/bar|tines|kalimba/)) {
                topology = 'stiff_string';
                stiffness = 0.8;
            } else if (prompt.match(/steel\s?drum|tongue|hang|pan|handpan/)) {
                topology = 'tongue_drum';
                stiffness = 0.05;
            } else if (prompt.match(/major\s?chord|happy/)) {
                topology = 'major_chord';
                detuneAmount = 0.01;
            } else if (prompt.match(/minor\s?chord|sad/)) {
                topology = 'minor_chord';
                detuneAmount = 0.01;
            } else if (prompt.match(/string|piano|guitar/)) {
                topology = 'harmonic';
                stiffness = prompt.includes('stiff') ? 0.2 : 0.0005; // Tuned matches trusting guitar
            } else if (prompt.match(/membrane|drum|skin/)) {
                topology = 'bessel';
            } else if (prompt.match(/vocal|voice|choir|formant/)) {
                topology = 'harmonic';
                clusterProb = 0.1;
            } else if (prompt.match(/wind|tube|flute|clarinet/)) {
                topology = 'odd';
            }

            // FALLBACK / PROCEDURAL MODE
            // If no keywords matched, pick a random physics model based on the seed
            if (!topology) {
                const types = ['harmonic', 'inharmonic', 'stiff_string', 'bessel', 'odd', 'tongue_drum'];
                topology = types[Math.floor(rng() * types.length)];

                // Randomize parameters since user didn't specify
                stiffness = rng() * 0.5;
                detuneAmount = rng() * 0.2;
                clusterProb = rng() * 0.3;
            }


            // --- RATIO GENERATION ---
            let currentRatio = 1.0;
            ratios.push(1.0);

            for (let i = 1; i < targetPartials; i++) {
                let nextR = 0;

                if (topology === 'harmonic') {
                    // Trusted Guitar Data matches: n * sqrt(1 + 0.0005 * n^2) roughly?
                    // Guitar: 1, 2.0199, 3.0668, 4.1569
                    // Ideal Harmonic: 1, 2, 3, 4
                    // Deviation: 0.0199, 0.0668, 0.1569.  Square growth.
                    // n * sqrt(1 + B*n^2) where B is very small (approx 0.00001 - 0.0001)
                    // Let's use the explicit Stiffness formula
                    let n = i + 1;
                    nextR = n * Math.sqrt(1 + stiffness * (n * n));
                }
                else if (topology === 'odd') {
                    nextR = 1 + i * 2;
                }
                else if (topology === 'stiff_string') {
                    // Standard Marimba/Bar
                    let n = i + 1;
                    // Stiff bars (Marimba) are often 1, 4, 9, 16 (approx 3.9, 9.2...)
                    // But our 'stiffness' param handles the mild inharmonicity
                    nextR = n * Math.sqrt(1 + stiffness * (n * n));
                }
                else if (topology === 'tongue_drum') {
                    // Trusted Steel Drum Data: 1.0, 1.99, 2.97, 3.94, (GAP) 5.79, 8.21, 10.51
                    // It mimics harmonic 1-4, then jumps.
                    // This suggests modes (1,0), (1,1) etc.
                    // Model: 1, 2, 3, 4, 6, 8, 10
                    if (i < 4) {
                        nextR = i + 1 + (rng() * 0.05 - 0.025); // Almost harmonic start
                    } else {
                        // After 4th partial, gaps widen
                        // i=4 -> 6 (approx 1.5x previous gap?)
                        currentRatio += (1.5 + rng() * 1.0);
                        nextR = currentRatio;
                    }
                }
                else if (topology === 'major_chord') {
                    // Major Chord Stack: 1, 1.25 (Maj3), 1.5 (P5), 2 (Oct), 2.5 (Maj10), 3 (P12), 4 (2Oct)
                    const majorIntervals = [1.0, 1.25, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 6.0, 8.0];
                    if (i < majorIntervals.length - 1) {
                        nextR = majorIntervals[i % majorIntervals.length];
                        nextR += (rng() * 0.005 - 0.0025);
                    } else {
                        nextR = (i + 1) * 0.5; // Dense harmonics
                    }
                }
                else if (topology === 'minor_chord') {
                    // Minor Chord Stack: 1, 1.2 (Min3), 1.5 (P5), 2 (Oct)...
                    const minorIntervals = [1.0, 1.2, 1.5, 2.0, 2.4, 3.0, 4.0, 4.8, 6.0, 8.0];
                    if (i < minorIntervals.length - 1) {
                        nextR = minorIntervals[i % minorIntervals.length];
                        nextR += (rng() * 0.005 - 0.0025);
                    } else {
                        nextR = (i + 1) * 0.5;
                    }
                }
                else if (topology === 'bessel') {
                    let step = 1.3 + (rng() * 0.6 - 0.3);
                    currentRatio += step;
                    nextR = currentRatio;
                }
                else if (topology === 'inharmonic') {
                    // Chaotic step
                    let step = 1.0 + (rng() * 0.8);
                    if (prompt.includes('broken') || prompt.includes('chaos')) step += rng();
                    currentRatio += step;
                    nextR = currentRatio;
                }

                // Apply detune lookup from RNG
                if (detuneAmount > 0) {
                    nextR += (rng() - 0.5) * detuneAmount;
                }

                // Clustering
                if (rng() < clusterProb) {
                    ratios.push(nextR);
                    let spread = 0.05 + rng() * 0.1;
                    ratios.push(nextR + spread);
                    i++;
                } else {
                    ratios.push(nextR);
                }
            }

            ratios = ratios.slice(0, targetPartials);
            ratios.sort((a, b) => a - b);


            // --- 2. SPECTRAL SHAPING (Gain) ---

            let brightness = 1.0;
            if (prompt.match(/bright|sharp|piercing/)) brightness = 0.5;
            else if (prompt.match(/dark|muffled|dull/)) brightness = 2.5;
            else {
                // Procedural brightness
                brightness = 0.5 + rng() * 2.0;
            }

            let texture = 'smooth';
            if (prompt.match(/scraped|rough|noisy|dirt/)) texture = 'noisy';
            else if (prompt.match(/hollow|box|comb/)) texture = 'comb';
            else {
                // Procedural texture chance
                const textures = ['smooth', 'smooth', 'noisy', 'comb'];
                texture = textures[Math.floor(rng() * textures.length)];
            }

            let gains = ratios.map(r => {
                let g = -10 * Math.log10(r) * brightness;

                if (texture === 'noisy') {
                    g += (rng() * 10 - 5);
                } else if (texture === 'comb') {
                    // Notch filter effect (sinusoidal)
                    g += 10 * Math.sin(r * 2);
                }

                if (prompt.match(/vocal|voice/)) {
                    g += 15 * Math.exp(-Math.pow(r - 3, 2) / 2);
                    g += 10 * Math.exp(-Math.pow(r - 8, 2) / 4);
                }

                if (g < -90) g = -90;
                return g;
            });


            // --- 3. DAMPING PHYSICS (Decay) ---

            let dampingModel = null;
            if (prompt.match(/wood|plastic|dry/)) dampingModel = 'exponential';
            else if (prompt.match(/metal|ring|sus/)) dampingModel = 'linear';
            else if (prompt.match(/glass|ice/)) dampingModel = 'glass';
            else {
                // Procedural damping
                const models = ['standard', 'exponential', 'linear', 'glass'];
                dampingModel = models[Math.floor(rng() * models.length)];
            }

            let decays = ratios.map((r, idx) => {
                let d = 1.0;

                if (dampingModel === 'exponential') {
                    d = 10.0 / (r * r);
                } else if (dampingModel === 'linear') {
                    d = 5.0 / Math.sqrt(r);
                } else if (dampingModel === 'glass') {
                    d = 0.5 + (rng() * 0.4);
                } else {
                    d = 5.0 / r;
                }

                // Global Decay Scaler matches keywords OR random
                let scaler = 1.0;
                if (prompt.match(/short|tight|dead/)) scaler = 0.2;
                else if (prompt.match(/long|huge|eternal/)) scaler = 4.0;
                else scaler = 0.5 + rng() * 1.5;

                d *= scaler;

                // Organic jitter
                d *= (0.8 + rng() * 0.4);

                if (d > 100) d = 100;
                if (d < 0.01) d = 0.01;

                return d;
            });


            // --- FORMAT OUTPUT ---
            // Include seed info in header for fun
            let csvRows = [`Ratio;GainDB;Decay`];
            // Disable debug log for production or user request? Keeping clean CSV for now based on original prompt instructions.
            // console.log(`Zebra Gen V3: Seed=${seed}, Topology=${topology}, Damping=${dampingModel}`);

            for (let i = 0; i < ratios.length; i++) {
                csvRows.push(`${ratios[i].toFixed(4)};${gains[i].toFixed(2)};${decays[i].toFixed(3)}`);
            }

            outputEl.innerText = csvRows.join('\n');
            outputSection.style.display = 'flex';
        }

        function copyToClipboard() {
            const text = document.getElementById('output').innerText;
            navigator.clipboard.writeText(text).then(() => {
                const btn = document.querySelector('.copy-btn');
                const original = btn.innerText;
                btn.innerText = 'Copied!';
                setTimeout(() => btn.innerText = original, 2000);
            });
        }
    </script>
</body>

</html>